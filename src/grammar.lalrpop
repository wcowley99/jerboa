use std::str::FromStr;
use crate::common::{Args, BinOp, FnDecl, ExprRef, FlatTree};
use crate::ast::Expr;

grammar(arena: &mut FlatTree<Expr>);

pub Program: (Vec<FnDecl>, ExprRef) = {
    <fns: Decl*> <e: Expr> => (fns, e),
}

Decl: FnDecl = {
    "fn" <n: Name> "(" <args: (Name ",")*> <a: Name?> ")" "{" <e: Expr> "}" => {
        let mut args = args.into_iter().map(|(arg, _)| arg).collect::<Vec<_>>();
        if let Some(a) = a { args.push(a); }

        FnDecl::new(n, Args(args), e)
    }
}

Expr: ExprRef = {
    #[precedence(level="0")] // Highest precedence
    Term,

    #[precedence(level="1")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => arena.add(Expr::Bin(BinOp::Mul, l, r)),
    <l:Expr> "/" <r:Expr> => arena.add(Expr::Bin(BinOp::Div, l, r)),

    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => arena.add(Expr::Bin(BinOp::Add, l, r)),
    <l:Expr> "-" <r:Expr> => arena.add(Expr::Bin(BinOp::Sub, l, r)),

    #[precedence(level="3")] #[assoc(side="left")]
    <l: Expr> "==" <r: Expr> => arena.add(Expr::Bin(BinOp::Eq, l, r)),
    <l: Expr> "!=" <r: Expr> => arena.add(Expr::Bin(BinOp::Neq, l, r)),
    <l: Expr> "<=" <r: Expr> => arena.add(Expr::Bin(BinOp::Leq, l, r)),
    <l: Expr> ">=" <r: Expr> => arena.add(Expr::Bin(BinOp::Geq, l, r)),
    <l: Expr> "<" <r: Expr> => arena.add(Expr::Bin(BinOp::Lt, l, r)),
    <l: Expr> ">" <r: Expr> => arena.add(Expr::Bin(BinOp::Gt, l, r)),
};

Term: ExprRef = {
    "(" <Expr> ")",
    "let" <id: Name> "=" <assn: Expr> "in" "{" <body: Expr> "}" => arena.add(Expr::Let(id, assn, body)),
    "if" <cond: Expr> "then" "{" <body: Expr> "}" "else" "{" <branch: Expr> "}" => arena.add(Expr::If(cond, body, branch)),
    "-" <t: Term> => arena.add(Expr::Neg(t)),
    <f: Name> "(" <args: (Expr ",")*> <e: Expr?> ")" => {
        let mut args = args.into_iter().map(|(e, _)| e).collect::<Vec<_>>();
        if let Some(e) = e { args.push(e); }

        arena.add(Expr::FnCall(f, args))
    },

    Imm,
};

Num: ExprRef = {
    r"[0-9]+" => arena.add(Expr::Num(i64::from_str(<>).unwrap())),
};

Imm: ExprRef = {
    Num,
    Bool,
    Var,
}

Bool: ExprRef = {
    "true" => arena.add(Expr::Bool(true)),
    "false" => arena.add(Expr::Bool(false)),
};

Var: ExprRef = {
    Name => arena.add(Expr::Var(<>)),
};

Name: String = {
    r"[a-zA-Z]+" => String::from(<>),
}
