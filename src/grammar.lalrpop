use std::str::FromStr;
use crate::common::{BinOp, CmpOp, ExprRef, FlatTree};
use crate::ast::Expr;

grammar(arena: &mut FlatTree<Expr>);

/* match {
    "+",
    "*",
    "(",
    ")",
    r"[0-9]+",
    r"[a-zA-Z]+",

    r"\s*" => {},
} */

pub Program: ExprRef = {
    Comparison,
}

Comparison: ExprRef = {
    <l: Expr> "==" <r: Expr> => arena.add(Expr::Cmp(CmpOp::Eq, l, r)),
    <l: Expr> "!=" <r: Expr> => arena.add(Expr::Cmp(CmpOp::Neq, l, r)),
    <l: Expr> "<=" <r: Expr> => arena.add(Expr::Cmp(CmpOp::Leq, l, r)),
    <l: Expr> ">=" <r: Expr> => arena.add(Expr::Cmp(CmpOp::Geq, l, r)),
    <l: Expr> "<" <r: Expr> => arena.add(Expr::Cmp(CmpOp::Lt, l, r)),
    <l: Expr> ">" <r: Expr> => arena.add(Expr::Cmp(CmpOp::Gt, l, r)),
    Expr,
}

Expr: ExprRef = {
    <l:Expr> "+" <r:Factor> => arena.add(Expr::Bin(BinOp::Add, l, r)),
    <l:Expr> "-" <r:Factor> => arena.add(Expr::Bin(BinOp::Sub, l, r)),
    Factor,
};

Factor: ExprRef = {
  <l:Factor> "*" <r:Term> => arena.add(Expr::Bin(BinOp::Mul, l, r)),
  <l:Factor> "/" <r:Term> => arena.add(Expr::Bin(BinOp::Div, l, r)),
  Term,
};

Term: ExprRef = {
    "(" <Expr> ")",
    "let" <id: Name> "=" <assn: Program> "in" "{" <body: Program> "}" => arena.add(Expr::Let(id, assn, body)),
    "if" <cond: Program> "then" "{" <body: Program> "}" "else" "{" <branch: Program> "}" => arena.add(Expr::If(cond, body, branch)),
    "-" <t: Term> => arena.add(Expr::Neg(t)),
    <f: Name> "(" <args: (Program ",")*> <e: Program?> ")" => {
        let mut args = args.into_iter().map(|(e, _)| e).collect::<Vec<_>>();
        if let Some(e) = e { args.push(e); }
        arena.add(Expr::FnCall(f, args))
    },

    Imm,
};

Num: ExprRef = {
    r"[0-9]+" => arena.add(Expr::Num(i64::from_str(<>).unwrap())),
};

Imm: ExprRef = {
    Num,
    Bool,
    Var,
}

Bool: ExprRef = {
    "true" => arena.add(Expr::Bool(true)),
    "false" => arena.add(Expr::Bool(false)),
};

Var: ExprRef = {
    Name => arena.add(Expr::Var(<>)),
};

Name: String = {
    r"[a-zA-Z]+" => String::from(<>),
}
