use std::str::FromStr;
use crate::common::{BinOp, FnDecl, ExprRef, FlatTree, Tag, Type};
use crate::ast::Expr;

grammar(arena: &mut FlatTree<(Tag, Expr)>);

pub Program: (Vec<FnDecl>, ExprRef) = {
    <fns: Decl*> <e: Expr> => (fns, e),
}

Decl: FnDecl = {
    <start: @L> "fn" <n: Name> <end: @R> "(" <args: (Name ":" Type ",")*> <a: (Name ":" Type)?> ")" "->" <t: Type> "{" <e: Expr> "}" => {
        let mut args = args.into_iter().map(|(arg, _, typ, _)| (arg, typ)).collect::<Vec<_>>();
        if let Some(a) = a.map(|(arg, _, typ)| (arg, typ)) { args.push(a); }

        FnDecl::new(n, args, Some(e), t, Tag::new(start, end))
    },

    <start: @L> "fn" <n: Name> <end: @R> "(" <args: (Name ":" Type ",")*> <a: (Name ":" Type)?> ")" "->" <t: Type> => {
        let mut args = args.into_iter().map(|(arg, _, typ, _)| (arg, typ)).collect::<Vec<_>>();
        if let Some(a) = a.map(|(arg, _, typ)| (arg, typ)) { args.push(a); }

        FnDecl::new(n, args, None, t, Tag::new(start, end))
    }
}

Expr: ExprRef = {
    #[precedence(level="0")] // Highest precedence
    Term,

    #[precedence(level="1")] #[assoc(side="left")]
    <start: @L> <l:Expr> "*" <r:Expr> <end: @R> => arena.add((Tag::new(start, end), Expr::Bin(BinOp::Mul, l, r))),
    <start: @L> <l:Expr> "/" <r:Expr> <end: @R> => arena.add((Tag::new(start, end), Expr::Bin(BinOp::Div, l, r))),

    #[precedence(level="2")] #[assoc(side="left")]
    <start: @L> <l:Expr> "+" <r:Expr> <end: @R> => arena.add((Tag::new(start, end), Expr::Bin(BinOp::Add, l, r))),
    <start: @L> <l:Expr> "-" <r:Expr> <end: @R> => arena.add((Tag::new(start, end), Expr::Bin(BinOp::Sub, l, r))),

    #[precedence(level="3")] #[assoc(side="left")]
    <start: @L> <l: Expr> "==" <r: Expr> <end: @R> => arena.add((Tag::new(start, end), Expr::Bin(BinOp::Eq, l, r))),
    <start: @L> <l: Expr> "!=" <r: Expr> <end: @R> => arena.add((Tag::new(start, end), Expr::Bin(BinOp::Neq, l, r))),
    <start: @L> <l: Expr> "<=" <r: Expr> <end: @R> => arena.add((Tag::new(start, end), Expr::Bin(BinOp::Leq, l, r))),
    <start: @L> <l: Expr> ">=" <r: Expr> <end: @R> => arena.add((Tag::new(start, end), Expr::Bin(BinOp::Geq, l, r))),
    <start: @L> <l: Expr> "<" <r: Expr> <end: @R> => arena.add((Tag::new(start, end), Expr::Bin(BinOp::Lt, l, r))),
    <start: @L> <l: Expr> ">" <r: Expr> <end: @R> => arena.add((Tag::new(start, end), Expr::Bin(BinOp::Gt, l, r))),
};

Term: ExprRef = {
    "(" <Expr> ")",
    <start: @L> "let" <id: Name> "=" <assn: Expr> "in" "{" <body: Expr> "}" <end: @R> => arena.add((Tag::new(start, end), Expr::Let(id, assn, body))),
    <start: @L> "if" <end: @R> <cond: Expr> "{" <body: Expr> "}" "else" "{" <branch: Expr> "}" => arena.add((Tag::new(start, end), Expr::If(cond, body, branch))),
    <start: @L> "-" <end: @R> <t: Term> => arena.add((Tag::new(start, end), Expr::Neg(t))),
    <start: @L> <f: Name> "(" <args: (Expr ",")*> <e: Expr?> ")" <end: @R> => {
        let mut args = args.into_iter().map(|(e, _)| e).collect::<Vec<_>>();
        if let Some(e) = e { args.push(e); }

        arena.add((Tag::new(start, end), Expr::FnCall(f, args)))
    },

    Imm,
};

Num: ExprRef = {
    <start: @L> <n: r"[0-9]+"> <end: @R> => arena.add((Tag::new(start, end), Expr::Num(i64::from_str(n).unwrap()))),
};

Imm: ExprRef = {
    Num,
    Bool,
    Var,
}

Bool: ExprRef = {
    <start: @L> "true" <end: @R> => arena.add((Tag::new(start, end), Expr::Bool(true))),
    <start: @L> "false" <end: @R> => arena.add((Tag::new(start, end), Expr::Bool(false))),
};

Var: ExprRef = {
    <start: @L> <n: Name> <end: @R> => arena.add((Tag::new(start, end), Expr::Var(n))),
};

Name: String = {
    r"[a-zA-Z][a-zA-Z0-9]*" => String::from(<>),
}

Type: Type = {
    "i64" => Type::I64,
    "bool" => Type::Bool,
}
